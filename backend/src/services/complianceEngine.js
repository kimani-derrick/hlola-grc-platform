const Control = require('../models/Control');
const Document = require('../models/Document');
const Task = require('../models/Task');
const AuditGap = require('../models/AuditGap');
const ComplianceHistory = require('../models/ComplianceHistory');
const logger = require('../config/logger');

class ComplianceEngine {
  /**
   * Main compliance check for an entity/framework combination
   * @param {string} entityId - Entity ID
   * @param {string} frameworkId - Framework ID
   * @returns {Object} Compliance result with score, gaps, and required controls count
   */
  static async checkEntityCompliance(entityId, frameworkId) {
    try {
      logger.info('Starting compliance check', { entityId, frameworkId });

      // 1. Get all controls for this framework
      const requiredControls = await Control.findByFrameworkId(frameworkId);
      logger.info('Retrieved required controls', { 
        frameworkId, 
        controlCount: requiredControls.length 
      });

      // 1.5. Get framework details for fine calculation
      const Framework = require('../models/Framework');
      const framework = await Framework.findById(frameworkId);
      logger.info('Retrieved framework details', { 
        frameworkId, 
        frameworkName: framework?.name,
        maxFineAmount: framework?.max_fine_amount,
        maxFineCurrency: framework?.max_fine_currency
      });

      // 2. Get existing evidence (documents, completed tasks)
      const entityEvidence = await this.getEntityEvidence(entityId);
      logger.info('Retrieved entity evidence', { 
        entityId, 
        documentCount: entityEvidence.documents.length,
        taskCount: entityEvidence.tasks.length
      });

      // 3. Compare required vs actual
      const gaps = await this.detectGaps(requiredControls, entityEvidence, frameworkId);
      logger.info('Detected gaps', { 
        entityId, 
        frameworkId, 
        gapCount: gaps.length 
      });

      // 4. Calculate compliance score
      const score = this.calculateScore(requiredControls, gaps);
      logger.info('Calculated compliance score', { 
        entityId, 
        frameworkId, 
        score 
      });

      // 4.5. Calculate risk exposure based on framework-level fines
      const riskExposure = this.calculateRiskExposure(requiredControls, gaps, framework);
      logger.info('Calculated risk exposure', { 
        entityId, 
        frameworkId, 
        totalExposure: riskExposure.totalExposure,
        currentExposure: riskExposure.currentExposure,
        exposurePercentage: riskExposure.exposurePercentage,
        currency: riskExposure.currency,
        compliancePercentage: riskExposure.compliancePercentage
      });

      // 5. Analyze existing tasks for gaps
      const taskAnalysis = await this.analyzeExistingTasks(gaps, entityId, frameworkId);
      logger.info('Analyzed existing tasks', { 
        entityId, 
        frameworkId,
        totalTasks: taskAnalysis.totalTasks,
        completedTasks: taskAnalysis.completedTasks,
        completionRate: taskAnalysis.completionRate,
        tasksForGaps: taskAnalysis.tasksForGaps.length
      });

      // 6. Create/update audit gaps
      await this.syncAuditGaps(gaps, entityId, frameworkId);
      logger.info('Synced audit gaps', { 
        entityId, 
        frameworkId, 
        gapCount: gaps.length 
      });

      // 7. Record compliance history
      await this.recordComplianceScore(entityId, frameworkId, score);
      logger.info('Recorded compliance score', { 
        entityId, 
        frameworkId, 
        score 
      });

      return { 
        score, 
        gaps, 
        requiredControls: requiredControls.length,
        taskAnalysis,
        riskExposure
      };
    } catch (error) {
      logger.error('Error in compliance check', {
        error: error.message,
        stack: error.stack,
        entityId,
        frameworkId
      });
      throw error;
    }
  }

  /**
   * Detect what's missing by comparing required controls with existing evidence
   * @param {Array} requiredControls - Array of required controls
   * @param {Object} entityEvidence - Object containing documents and tasks
   * @param {string} frameworkId - Framework ID for gap tracking
   * @returns {Array} Array of detected gaps
   */
  static async detectGaps(requiredControls, entityEvidence, frameworkId) {
    const gaps = [];
    
    for (const control of requiredControls) {
      const hasEvidence = this.checkControlEvidence(control, entityEvidence);
      
      if (!hasEvidence) {
        const gap = {
          controlId: control.id,
          frameworkId: frameworkId,
          title: `Missing: ${control.title}`,
          description: control.description,
          category: this.determineCategory(control),
          severity: control.risk_level || 'medium',
          requiredDocumentType: control.evidence_type,
          autoGenerated: true
        };
        gaps.push(gap);
        
        logger.debug('Gap detected', {
          controlId: control.id,
          controlTitle: control.title,
          category: gap.category,
          severity: gap.severity
        });
      }
    }
    
    return gaps;
  }

  /**
   * Check if control has proper evidence
   * @param {Object} control - Control object
   * @param {Object} evidence - Evidence object with documents and tasks
   * @returns {boolean} True if evidence exists
   */
  static checkControlEvidence(control, evidence) {
    // Check for documents that match control requirements
    const hasDocument = evidence.documents.some(doc => 
      this.matchesControlRequirements(doc, control)
    );
    
    // Check for completed tasks related to this control
    const hasCompletedTask = evidence.tasks.some(task => 
      task.control_id === control.id && task.status === 'completed'
    );
    
    // For compliance, we accept EITHER completed tasks OR evidence documents
    // Completed tasks count as evidence by themselves
    const hasEvidence = hasCompletedTask || hasDocument;
    
    logger.debug('Control evidence check', {
      controlId: control.id,
      hasDocument,
      hasCompletedTask,
      hasEvidence,
      requirement: 'task_or_document_evidence'
    });
    
    return hasEvidence;
  }

  /**
   * Check if document matches control requirements
   * @param {Object} document - Document object
   * @param {Object} control - Control object
   * @returns {boolean} True if document matches requirements
   */
  static matchesControlRequirements(document, control) {
    // Check document type matches control evidence type
    if (control.evidence_type && document.document_type !== control.evidence_type) {
      return false;
    }
    
    // Check if document is related to this control
    // If document has a specific control_id, it must match
    if (document.control_id) {
      return document.control_id === control.id;
    }
    
    // If document has no control_id, it's a general document
    // Only count it as evidence if it's specifically marked as general evidence
    // For now, we'll be strict: only documents linked to specific controls count
    return false;
  }

  /**
   * Determine category based on control properties
   * @param {Object} control - Control object
   * @returns {string} Category string
   */
  static determineCategory(control) {
    // Simple categorization based on control title and description
    const title = (control.title || '').toLowerCase();
    const description = (control.description || '').toLowerCase();
    
    if (title.includes('policy') || title.includes('procedure') || description.includes('document')) {
      return 'documentation';
    }
    
    if (title.includes('technical') || title.includes('system') || title.includes('security')) {
      return 'technical';
    }
    
    if (title.includes('process') || title.includes('workflow') || title.includes('procedure')) {
      return 'procedural';
    }
    
    return 'evidence';
  }

  /**
   * Calculate compliance percentage
   * @param {Array} requiredControls - Array of required controls
   * @param {Array} gaps - Array of detected gaps
   * @returns {number} Compliance score (0-100)
   */
  static calculateScore(requiredControls, gaps) {
    const totalRequired = requiredControls.length;
    const missing = gaps.length;
    const compliant = totalRequired - missing;
    
    if (totalRequired === 0) {
      return 100; // No requirements = 100% compliant
    }
    
    const score = Math.round((compliant / totalRequired) * 100);
    return Math.max(0, Math.min(100, score)); // Ensure score is between 0-100
  }

  /**
   * Calculate risk exposure based on framework-level fines and compliance percentage
   * @param {Array} requiredControls - Array of required controls
   * @param {Array} gaps - Array of detected gaps
   * @param {Object} framework - Framework object with max_fine_amount
   * @returns {Object} Risk exposure data
   */
  static calculateRiskExposure(requiredControls, gaps, framework) {
    // Framework-level maximum fine amount
    const maxFineAmount = framework?.max_fine_amount || 0;
    const fineCurrency = framework?.max_fine_currency || 'EUR';
    
    // Calculate compliance percentage
    const totalControls = requiredControls.length;
    const compliantControls = totalControls - gaps.length;
    const compliancePercentage = totalControls > 0 
      ? Math.round((compliantControls / totalControls) * 100)
      : 100;
    
    // Risk exposure is proportional to non-compliance
    // If 100% compliant = 0% exposure, if 0% compliant = 100% exposure
    const nonCompliancePercentage = 100 - compliancePercentage;
    const currentExposure = Math.round((maxFineAmount * nonCompliancePercentage) / 100);
    
    return {
      totalExposure: maxFineAmount,
      currentExposure: currentExposure,
      exposurePercentage: nonCompliancePercentage,
      currency: fineCurrency,
      controlsAtRisk: gaps.length,
      totalControls: totalControls,
      compliancePercentage: compliancePercentage,
      maxFineAmount: maxFineAmount
    };
  }

  /**
   * Get all evidence for an entity
   * @param {string} entityId - Entity ID
   * @returns {Object} Object containing documents and tasks
   */
  static async getEntityEvidence(entityId) {
    try {
      // Get organization ID from entity
      const Entity = require('../models/Entity');
      const entity = await Entity.findById(entityId);
      if (!entity) {
        logger.warn('Entity not found for evidence retrieval', { entityId });
        return { documents: [], tasks: [] };
      }
      
      const [documents, tasks] = await Promise.all([
        Document.findByEntity(entityId, entity.organization_id),
        Task.findByEntityId(entityId, organizationId)
      ]);
      
      return { documents, tasks };
    } catch (error) {
      logger.error('Error getting entity evidence', {
        error: error.message,
        entityId
      });
      return { documents: [], tasks: [] };
    }
  }

  /**
   * Analyze existing tasks for gaps and return task status
   * @param {Array} gaps - Array of detected gaps
   * @param {string} entityId - Entity ID
   * @param {string} frameworkId - Framework ID to filter tasks
   * @returns {Object} Task analysis object
   */
  static async analyzeExistingTasks(gaps, entityId, frameworkId) {
    try {
      logger.info('Starting task analysis', { entityId, frameworkId, gapCount: gaps.length });
      
      // Get entity to get organizationId
      const Entity = require('../models/Entity');
      const entity = await Entity.findById(entityId);
      if (!entity) {
        throw new Error('Entity not found');
      }
      
      // Get all tasks for this entity
      const allTasks = await Task.findByEntityId(entityId, entity.organization_id);
      logger.info('Retrieved tasks from database', { entityId, totalTasks: allTasks.length });
      
      // Filter tasks by framework
      const frameworkTasks = allTasks.filter(task => task.framework_id === frameworkId);
      logger.info('Filtered tasks by framework', { entityId, frameworkId, frameworkTasks: frameworkTasks.length });
      
      // Calculate overall task statistics
      const taskStats = {
        totalTasks: frameworkTasks.length,
        pendingTasks: frameworkTasks.filter(t => t.status === 'pending').length,
        inProgressTasks: frameworkTasks.filter(t => t.status === 'in-progress').length,
        completedTasks: frameworkTasks.filter(t => t.status === 'completed').length,
        blockedTasks: frameworkTasks.filter(t => t.status === 'blocked').length,
        cancelledTasks: frameworkTasks.filter(t => t.status === 'cancelled').length,
        highPriorityTasks: frameworkTasks.filter(t => t.priority === 'high').length,
        mediumPriorityTasks: frameworkTasks.filter(t => t.priority === 'medium').length,
        lowPriorityTasks: frameworkTasks.filter(t => t.priority === 'low').length
      };

      // Find tasks related to gaps
      const tasksForGaps = [];
      for (const gap of gaps) {
        const relatedTasks = frameworkTasks.filter(task => task.control_id === gap.controlId);
        
        for (const task of relatedTasks) {
          tasksForGaps.push({
            controlId: gap.controlId,
            taskId: task.id,
            title: task.title,
            status: task.status,
            priority: task.priority,
            dueDate: task.due_date,
            progress: task.progress || 0,
            assigneeId: task.assignee_id,
            assigneeName: task.assignee_first_name && task.assignee_last_name 
              ? `${task.assignee_first_name} ${task.assignee_last_name}` 
              : null
          });
        }
      }

      // Calculate completion rate
      const completionRate = taskStats.totalTasks > 0 
        ? Math.round((taskStats.completedTasks / taskStats.totalTasks) * 100)
        : 0;

      logger.info('Task analysis completed', {
        entityId,
        totalTasks: taskStats.totalTasks,
        completedTasks: taskStats.completedTasks,
        completionRate,
        tasksForGaps: tasksForGaps.length
      });

      return {
        ...taskStats,
        completionRate,
        tasksForGaps
      };
    } catch (error) {
      logger.error('Error analyzing existing tasks', {
        error: error.message,
        entityId,
        gapCount: gaps.length
      });
      return {
        totalTasks: 0,
        pendingTasks: 0,
        inProgressTasks: 0,
        completedTasks: 0,
        blockedTasks: 0,
        cancelledTasks: 0,
        highPriorityTasks: 0,
        mediumPriorityTasks: 0,
        lowPriorityTasks: 0,
        completionRate: 0,
        tasksForGaps: []
      };
    }
  }

  /**
   * Sync gaps with audit_gaps table
   * @param {Array} gaps - Array of detected gaps
   * @param {string} entityId - Entity ID
   * @param {string} frameworkId - Framework ID
   */
  static async syncAuditGaps(gaps, entityId, frameworkId) {
    try {
      // Get organization ID from entity
      const Entity = require('../models/Entity');
      const entity = await Entity.findById(entityId);
      if (!entity) {
        logger.warn('Entity not found for gap sync', { entityId });
        return;
      }
      
      const organizationId = entity.organization_id;
      
      // Get existing gaps for this entity/framework combination
      const existingGaps = await AuditGap.findAll({ 
        organizationId, 
        entityId, 
        frameworkId 
      });
      
      logger.info('Found existing gaps', { 
        entityId, 
        frameworkId, 
        existingCount: existingGaps.length 
      });
      
      // Create new gaps
      for (const gap of gaps) {
        const exists = existingGaps.some(eg => eg.control_id === gap.controlId);
        if (!exists) {
          await AuditGap.create({
            organizationId,
            entityId,
            frameworkId,
            controlId: gap.controlId,
            title: gap.title,
            description: gap.description,
            category: gap.category,
            severity: gap.severity,
            status: 'open',
            autoGenerated: true
          });
          
          logger.info('Created new audit gap', {
            entityId,
            frameworkId,
            controlId: gap.controlId,
            title: gap.title
          });
        }
      }
      
      // Close resolved gaps (gaps that no longer exist)
      const currentControlIds = gaps.map(g => g.controlId);
      for (const existingGap of existingGaps) {
        if (!currentControlIds.includes(existingGap.control_id) && 
            existingGap.status !== 'closed') {
          await AuditGap.updateStatus(existingGap.id, 'closed', new Date());
          
          logger.info('Closed resolved audit gap', {
            gapId: existingGap.id,
            controlId: existingGap.control_id,
            title: existingGap.title
          });
        }
      }
    } catch (error) {
      logger.error('Error syncing audit gaps', {
        error: error.message,
        entityId,
        frameworkId
      });
      throw error;
    }
  }

  /**
   * Record compliance score in history
   * @param {string} entityId - Entity ID
   * @param {string} frameworkId - Framework ID
   * @param {number} score - Compliance score
   */
  static async recordComplianceScore(entityId, frameworkId, score) {
    try {
      // Get organization ID from entity
      const Entity = require('../models/Entity');
      const entity = await Entity.findById(entityId);
      if (!entity) {
        logger.warn('Entity not found for compliance history', { entityId });
        return;
      }
      
      const organizationId = entity.organization_id;
      
      await ComplianceHistory.create({
        organizationId,
        entityId,
        frameworkId,
        complianceScore: score,
        milestone: 'Automated Compliance Check',
        eventType: 'update',
        eventDate: new Date().toISOString().split('T')[0],
        description: `Automated compliance check completed. Score: ${score}%`
      });
      
      logger.info('Recorded compliance score in history', {
        entityId,
        frameworkId,
        score
      });
    } catch (error) {
      logger.error('Error recording compliance score', {
        error: error.message,
        entityId,
        frameworkId,
        score
      });
      // Don't throw error here as it's not critical
    }
  }
}

module.exports = ComplianceEngine;
