const Control = require('../models/Control');
const Document = require('../models/Document');
const Task = require('../models/Task');
const AuditGap = require('../models/AuditGap');
const ComplianceHistory = require('../models/ComplianceHistory');
const logger = require('../config/logger');

class ComplianceEngine {
  /**
   * Main compliance check for an entity/framework combination
   * @param {string} entityId - Entity ID
   * @param {string} frameworkId - Framework ID
   * @returns {Object} Compliance result with score, gaps, and required controls count
   */
  static async checkEntityCompliance(entityId, frameworkId) {
    try {
      logger.info('Starting compliance check', { entityId, frameworkId });

      // 1. Get all controls for this framework
      const requiredControls = await Control.findByFrameworkId(frameworkId);
      logger.info('Retrieved required controls', { 
        frameworkId, 
        controlCount: requiredControls.length 
      });

      // 2. Get existing evidence (documents, completed tasks)
      const entityEvidence = await this.getEntityEvidence(entityId);
      logger.info('Retrieved entity evidence', { 
        entityId, 
        documentCount: entityEvidence.documents.length,
        taskCount: entityEvidence.tasks.length
      });

      // 3. Compare required vs actual
      const gaps = await this.detectGaps(requiredControls, entityEvidence);
      logger.info('Detected gaps', { 
        entityId, 
        frameworkId, 
        gapCount: gaps.length 
      });

      // 4. Calculate compliance score
      const score = this.calculateScore(requiredControls, gaps);
      logger.info('Calculated compliance score', { 
        entityId, 
        frameworkId, 
        score 
      });

      // 5. Generate tasks for gaps
      const TaskGenerator = require('./taskGenerator');
      const createdTasks = await TaskGenerator.createTasksFromGaps(gaps, entityId);
      logger.info('Generated tasks from gaps', { 
        entityId, 
        taskCount: createdTasks.length 
      });

      // 6. Create/update audit gaps
      await this.syncAuditGaps(gaps, entityId, frameworkId);
      logger.info('Synced audit gaps', { 
        entityId, 
        frameworkId, 
        gapCount: gaps.length 
      });

      // 7. Record compliance history
      await this.recordComplianceScore(entityId, frameworkId, score);
      logger.info('Recorded compliance score', { 
        entityId, 
        frameworkId, 
        score 
      });

      return { 
        score, 
        gaps, 
        requiredControls: requiredControls.length,
        tasksGenerated: createdTasks.length
      };
    } catch (error) {
      logger.error('Error in compliance check', {
        error: error.message,
        stack: error.stack,
        entityId,
        frameworkId
      });
      throw error;
    }
  }

  /**
   * Detect what's missing by comparing required controls with existing evidence
   * @param {Array} requiredControls - Array of required controls
   * @param {Object} entityEvidence - Object containing documents and tasks
   * @returns {Array} Array of detected gaps
   */
  static async detectGaps(requiredControls, entityEvidence) {
    const gaps = [];
    
    for (const control of requiredControls) {
      const hasEvidence = this.checkControlEvidence(control, entityEvidence);
      
      if (!hasEvidence) {
        const gap = {
          controlId: control.id,
          title: `Missing: ${control.title}`,
          description: control.description,
          category: this.determineCategory(control),
          severity: control.risk_level || 'medium',
          requiredDocumentType: control.evidence_type,
          autoGenerated: true
        };
        gaps.push(gap);
        
        logger.debug('Gap detected', {
          controlId: control.id,
          controlTitle: control.title,
          category: gap.category,
          severity: gap.severity
        });
      }
    }
    
    return gaps;
  }

  /**
   * Check if control has proper evidence
   * @param {Object} control - Control object
   * @param {Object} evidence - Evidence object with documents and tasks
   * @returns {boolean} True if evidence exists
   */
  static checkControlEvidence(control, evidence) {
    // Check for documents that match control requirements
    const hasDocument = evidence.documents.some(doc => 
      this.matchesControlRequirements(doc, control)
    );
    
    // Check for completed tasks related to this control
    const hasCompletedTask = evidence.tasks.some(task => 
      task.control_id === control.id && task.status === 'completed'
    );
    
    const hasEvidence = hasDocument || hasCompletedTask;
    
    logger.debug('Control evidence check', {
      controlId: control.id,
      hasDocument,
      hasCompletedTask,
      hasEvidence
    });
    
    return hasEvidence;
  }

  /**
   * Check if document matches control requirements
   * @param {Object} document - Document object
   * @param {Object} control - Control object
   * @returns {boolean} True if document matches requirements
   */
  static matchesControlRequirements(document, control) {
    // Check document type matches control evidence type
    if (control.evidence_type && document.document_type !== control.evidence_type) {
      return false;
    }
    
    // Check if document is related to this control (if control_id is set)
    if (document.control_id && document.control_id !== control.id) {
      return false;
    }
    
    // Additional matching logic can be added here
    // For now, we'll consider it a match if document type matches
    return true;
  }

  /**
   * Determine category based on control properties
   * @param {Object} control - Control object
   * @returns {string} Category string
   */
  static determineCategory(control) {
    // Simple categorization based on control title and description
    const title = (control.title || '').toLowerCase();
    const description = (control.description || '').toLowerCase();
    
    if (title.includes('policy') || title.includes('procedure') || description.includes('document')) {
      return 'documentation';
    }
    
    if (title.includes('technical') || title.includes('system') || title.includes('security')) {
      return 'technical';
    }
    
    if (title.includes('process') || title.includes('workflow') || title.includes('procedure')) {
      return 'procedural';
    }
    
    return 'evidence';
  }

  /**
   * Calculate compliance percentage
   * @param {Array} requiredControls - Array of required controls
   * @param {Array} gaps - Array of detected gaps
   * @returns {number} Compliance score (0-100)
   */
  static calculateScore(requiredControls, gaps) {
    const totalRequired = requiredControls.length;
    const missing = gaps.length;
    const compliant = totalRequired - missing;
    
    if (totalRequired === 0) {
      return 100; // No requirements = 100% compliant
    }
    
    const score = Math.round((compliant / totalRequired) * 100);
    return Math.max(0, Math.min(100, score)); // Ensure score is between 0-100
  }

  /**
   * Get all evidence for an entity
   * @param {string} entityId - Entity ID
   * @returns {Object} Object containing documents and tasks
   */
  static async getEntityEvidence(entityId) {
    try {
      const [documents, tasks] = await Promise.all([
        Document.findByEntity(entityId),
        Task.findByEntity(entityId)
      ]);
      
      return { documents, tasks };
    } catch (error) {
      logger.error('Error getting entity evidence', {
        error: error.message,
        entityId
      });
      return { documents: [], tasks: [] };
    }
  }

  /**
   * Sync gaps with audit_gaps table
   * @param {Array} gaps - Array of detected gaps
   * @param {string} entityId - Entity ID
   * @param {string} frameworkId - Framework ID
   */
  static async syncAuditGaps(gaps, entityId, frameworkId) {
    try {
      // Get organization ID from entity
      const Entity = require('../models/Entity');
      const entity = await Entity.findById(entityId);
      if (!entity) {
        logger.warn('Entity not found for gap sync', { entityId });
        return;
      }
      
      const organizationId = entity.organization_id;
      
      // Get existing gaps for this entity/framework combination
      const existingGaps = await AuditGap.findAll({ 
        organizationId, 
        entityId, 
        frameworkId 
      });
      
      logger.info('Found existing gaps', { 
        entityId, 
        frameworkId, 
        existingCount: existingGaps.length 
      });
      
      // Create new gaps
      for (const gap of gaps) {
        const exists = existingGaps.some(eg => eg.control_id === gap.controlId);
        if (!exists) {
          await AuditGap.create({
            organizationId,
            entityId,
            frameworkId,
            controlId: gap.controlId,
            title: gap.title,
            description: gap.description,
            category: gap.category,
            severity: gap.severity,
            status: 'open',
            autoGenerated: true
          });
          
          logger.info('Created new audit gap', {
            entityId,
            frameworkId,
            controlId: gap.controlId,
            title: gap.title
          });
        }
      }
      
      // Close resolved gaps (gaps that no longer exist)
      const currentControlIds = gaps.map(g => g.controlId);
      for (const existingGap of existingGaps) {
        if (!currentControlIds.includes(existingGap.control_id) && 
            existingGap.status !== 'closed') {
          await AuditGap.updateStatus(existingGap.id, 'closed', new Date());
          
          logger.info('Closed resolved audit gap', {
            gapId: existingGap.id,
            controlId: existingGap.control_id,
            title: existingGap.title
          });
        }
      }
    } catch (error) {
      logger.error('Error syncing audit gaps', {
        error: error.message,
        entityId,
        frameworkId
      });
      throw error;
    }
  }

  /**
   * Record compliance score in history
   * @param {string} entityId - Entity ID
   * @param {string} frameworkId - Framework ID
   * @param {number} score - Compliance score
   */
  static async recordComplianceScore(entityId, frameworkId, score) {
    try {
      // Get organization ID from entity
      const Entity = require('../models/Entity');
      const entity = await Entity.findById(entityId);
      if (!entity) {
        logger.warn('Entity not found for compliance history', { entityId });
        return;
      }
      
      const organizationId = entity.organization_id;
      
      await ComplianceHistory.create({
        organizationId,
        entityId,
        frameworkId,
        complianceScore: score,
        milestone: 'Automated Compliance Check',
        eventType: 'update',
        eventDate: new Date().toISOString().split('T')[0],
        description: `Automated compliance check completed. Score: ${score}%`
      });
      
      logger.info('Recorded compliance score in history', {
        entityId,
        frameworkId,
        score
      });
    } catch (error) {
      logger.error('Error recording compliance score', {
        error: error.message,
        entityId,
        frameworkId,
        score
      });
      // Don't throw error here as it's not critical
    }
  }
}

module.exports = ComplianceEngine;
