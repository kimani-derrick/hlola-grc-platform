const Task = require('../models/Task');
const logger = require('../config/logger');

class TaskGenerator {
  /**
   * Create tasks from detected gaps
   * @param {Array} gaps - Array of detected gaps
   * @param {string} entityId - Entity ID
   * @returns {Array} Array of created tasks
   */
  static async createTasksFromGaps(gaps, entityId) {
    const createdTasks = [];
    
    try {
      logger.info('Creating tasks from gaps', { 
        entityId, 
        gapCount: gaps.length 
      });
      
      for (const gap of gaps) {
        // Skip if task already exists for this control
        const existingTask = await Task.findByControl(gap.controlId);
        if (existingTask && existingTask.status !== 'completed') {
          logger.debug('Skipping task creation - existing task found', {
            controlId: gap.controlId,
            existingTaskId: existingTask.id,
            status: existingTask.status
          });
          continue;
        }
        
        const taskData = {
          entityId,
          controlId: gap.controlId,
          title: this.generateTaskTitle(gap),
          description: this.generateTaskDescription(gap),
          priority: this.mapSeverityToPriority(gap.severity),
          dueDate: this.calculateDueDate(gap.severity),
          status: 'pending',
          autoGenerated: true
        };
        
        const task = await Task.create(taskData);
        createdTasks.push(task);
        
        logger.info('Created task from gap', {
          taskId: task.id,
          controlId: gap.controlId,
          title: task.title,
          priority: task.priority,
          dueDate: task.dueDate
        });
      }
      
      logger.info('Task generation completed', {
        entityId,
        gapsProcessed: gaps.length,
        tasksCreated: createdTasks.length
      });
      
      return createdTasks;
    } catch (error) {
      logger.error('Error creating tasks from gaps', {
        error: error.message,
        stack: error.stack,
        entityId,
        gapCount: gaps.length
      });
      throw error;
    }
  }

  /**
   * Generate task title from gap
   * @param {Object} gap - Gap object
   * @returns {string} Task title
   */
  static generateTaskTitle(gap) {
    const baseTitle = gap.title.replace('Missing: ', '');
    return `Complete: ${baseTitle}`;
  }

  /**
   * Generate task description from gap
   * @param {Object} gap - Gap object
   * @returns {string} Task description
   */
  static generateTaskDescription(gap) {
    const action = this.getActionForCategory(gap.category);
    const evidenceType = gap.requiredDocumentType || 'Document or Proof';
    
    return `${gap.description}\n\n` +
           `Required Action: ${action}\n` +
           `Evidence Type: ${evidenceType}\n` +
           `Category: ${gap.category}\n` +
           `Severity: ${gap.severity}`;
  }

  /**
   * Map severity to task priority
   * @param {string} severity - Gap severity
   * @returns {string} Task priority
   */
  static mapSeverityToPriority(severity) {
    const mapping = {
      'critical': 'high',
      'high': 'high',
      'medium': 'medium',
      'low': 'low'
    };
    return mapping[severity] || 'medium';
  }

  /**
   * Calculate due date based on severity
   * @param {string} severity - Gap severity
   * @returns {Date} Due date
   */
  static calculateDueDate(severity) {
    const daysMap = {
      'critical': 7,
      'high': 14,
      'medium': 30,
      'low': 60
    };
    
    const days = daysMap[severity] || 30;
    const dueDate = new Date();
    dueDate.setDate(dueDate.getDate() + days);
    return dueDate;
  }

  /**
   * Get action description for category
   * @param {string} category - Gap category
   * @returns {string} Action description
   */
  static getActionForCategory(category) {
    const actions = {
      'documentation': 'Upload required policy or procedure document',
      'technical': 'Implement technical control and provide evidence',
      'procedural': 'Establish process and document procedures',
      'evidence': 'Provide evidence of compliance'
    };
    return actions[category] || 'Complete required action';
  }

  /**
   * Create a single task for a specific gap
   * @param {Object} gap - Gap object
   * @param {string} entityId - Entity ID
   * @param {string} assignedTo - User ID to assign task to (optional)
   * @returns {Object} Created task
   */
  static async createSingleTask(gap, entityId, assignedTo = null) {
    try {
      const taskData = {
        entityId,
        controlId: gap.controlId,
        title: this.generateTaskTitle(gap),
        description: this.generateTaskDescription(gap),
        priority: this.mapSeverityToPriority(gap.severity),
        dueDate: this.calculateDueDate(gap.severity),
        status: 'pending',
        autoGenerated: true,
        assignedTo
      };
      
      const task = await Task.create(taskData);
      
      logger.info('Created single task from gap', {
        taskId: task.id,
        controlId: gap.controlId,
        entityId,
        assignedTo
      });
      
      return task;
    } catch (error) {
      logger.error('Error creating single task', {
        error: error.message,
        gap,
        entityId,
        assignedTo
      });
      throw error;
    }
  }

  /**
   * Update existing task based on gap changes
   * @param {string} taskId - Task ID
   * @param {Object} gap - Updated gap object
   * @returns {Object} Updated task
   */
  static async updateTaskFromGap(taskId, gap) {
    try {
      const updateData = {
        title: this.generateTaskTitle(gap),
        description: this.generateTaskDescription(gap),
        priority: this.mapSeverityToPriority(gap.severity),
        dueDate: this.calculateDueDate(gap.severity)
      };
      
      const task = await Task.update(taskId, updateData);
      
      logger.info('Updated task from gap', {
        taskId,
        controlId: gap.controlId,
        title: task.title
      });
      
      return task;
    } catch (error) {
      logger.error('Error updating task from gap', {
        error: error.message,
        taskId,
        gap
      });
      throw error;
    }
  }

  /**
   * Get task statistics for an entity
   * @param {string} entityId - Entity ID
   * @returns {Object} Task statistics
   */
  static async getTaskStatistics(entityId) {
    try {
      const tasks = await Task.findByEntity(entityId);
      
      const stats = {
        total: tasks.length,
        pending: tasks.filter(t => t.status === 'pending').length,
        inProgress: tasks.filter(t => t.status === 'in-progress').length,
        completed: tasks.filter(t => t.status === 'completed').length,
        overdue: tasks.filter(t => t.status === 'overdue').length,
        autoGenerated: tasks.filter(t => t.autoGenerated === true).length,
        highPriority: tasks.filter(t => t.priority === 'high').length,
        critical: tasks.filter(t => t.priority === 'critical').length
      };
      
      logger.debug('Task statistics calculated', {
        entityId,
        stats
      });
      
      return stats;
    } catch (error) {
      logger.error('Error getting task statistics', {
        error: error.message,
        entityId
      });
      return {
        total: 0,
        pending: 0,
        inProgress: 0,
        completed: 0,
        overdue: 0,
        autoGenerated: 0,
        highPriority: 0,
        critical: 0
      };
    }
  }
}

module.exports = TaskGenerator;
